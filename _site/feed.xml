<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>七色璎珞</title>
		<description>Stylish Jekyll Theme</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Vue.js相关资源</title>
				<description>&lt;h3 id=&quot;vuehttpcnvuejsorg&quot;&gt;&lt;a href=&quot;http://cn.vuejs.org/&quot;&gt;vue中文社区&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;vuehttpssegmentfaultcoma1190000005009052&quot;&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005009052&quot;&gt;vue构建单页应用最佳实战&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;vue-resourcehttpwwwdoc00comdoc1001004eg&quot;&gt;&lt;a href=&quot;http://www.doc00.com/doc/1001004eg&quot;&gt;vue-resource用法介绍&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;vuerifyhttpsgithubcomqingwei-livuerifywikie5b8aee58aa9e69687e6a1a3&quot;&gt;&lt;a href=&quot;https://github.com/QingWei-Li/vuerify/wiki/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3&quot;&gt;vuerify文档&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;webpackhttpwwwjianshucomp42e11515c10f&quot;&gt;&lt;a href=&quot;http://www.jianshu.com/p/42e11515c10f#&quot;&gt;webpack入门&lt;/a&gt;&lt;/h3&gt;
</description>
				<pubDate>Sun, 30 Oct 2016 00:00:00 +0800</pubDate>
				<link>/frontend/2016/10/30/vue-resource.html</link>
				<guid isPermaLink="true">/frontend/2016/10/30/vue-resource.html</guid>
			</item>
		
			<item>
				<title>Android工程去除OpenCV依赖</title>
				<description>&lt;p&gt;采用静态初始化的方法，可以戳下边的链接查看官方的文档介绍
http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/dev_with_OCV_on_Android.html#application-development-with-static-initialization&lt;/p&gt;

&lt;p&gt;如果项目不包含JNI部分，比较简单的办法就是：&lt;/p&gt;

&lt;p&gt;1）注销掉OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_3, this, mLoaderCallback); 在语句上边直接设为SUCCESS。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void onResume()&lt;/span&gt;
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;super.onResume();&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_3, this, mLoaderCallback);&lt;/span&gt;
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2）在Activity类中添加静态的方法&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;static{&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;if(!OpenCVLoader.initDebug()){&lt;/span&gt;
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//handle initialization error&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如果有其他的自定义原生库需要加载，可以在这里添加else语句：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;static{&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;if(!OpenCVLoader.initDebug()){&lt;/span&gt;
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//handle initialization error&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}else{&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;　　System.loadLibrary(&amp;quot;my_jni_lib1&amp;quot;);&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;　　System.loadLibrary(&amp;quot;my_jni_lib2&amp;quot;);&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;OpenCV for Android 3.0版本里，示例程序直接就可免OpenCV Manager的安装，它的初始代码onResume函数中是这样写的：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void onResume()&lt;/span&gt;
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;super.onResume();&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;if (!OpenCVLoader.initDebug()) {&lt;/span&gt;
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;Log.d(TAG, &amp;quot;Internal OpenCV library not found. Using OpenCV Manager for initialization&amp;quot;);&lt;/span&gt;
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;} else {&lt;/span&gt;
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;Log.d(TAG, &amp;quot;OpenCV library found inside package. Using it!&amp;quot;);&lt;/span&gt;
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);&lt;/span&gt;
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这样的写法在OpenCV 4.xx中同样适用，所以推荐下边的这种方法。&lt;/p&gt;
</description>
				<pubDate>Fri, 20 Nov 2015 00:00:00 +0800</pubDate>
				<link>/opencv/2015/11/20/opencv-manager.html</link>
				<guid isPermaLink="true">/opencv/2015/11/20/opencv-manager.html</guid>
			</item>
		
			<item>
				<title>MQTT协议之订阅及发布</title>
				<description>&lt;p&gt;1.消息接收回调类&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttCallback;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttDeliveryToken;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttMessage;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttTopic;&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;/**&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;* 发布消息的回调类&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*&lt;/span&gt;   
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;* 必须实现MqttCallback的接口并实现对应的相关接口方法&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*      ◦CallBack 类将实现 MqttCallBack。每个客户机标识都需要一个回调实例。在此示例中，构造函数传递客户机标识以另存为实例数据。在回调中，将它用来标识已经启动了该回调的哪个实例。&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  ◦必须在回调类中实现三个方法：&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*&lt;/span&gt;   
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  public void messageArrived(MqttTopic topic, MqttMessage message)&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  接收已经预订的发布。&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*&lt;/span&gt;   
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  public void connectionLost(Throwable cause)&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  在断开连接时调用。&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*&lt;/span&gt;   
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  public void deliveryComplete(MqttDeliveryToken token))&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*      接收到已经发布的 QoS 1 或 QoS 2 消息的传递令牌时调用。&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*  ◦由 MqttClient.connect 激活此回调。&lt;/span&gt;  
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*&lt;/span&gt;   
 &lt;span class=&quot;l-Scalar-Plain&quot;&gt;*/&lt;/span&gt;    
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;public class PushCallback implements MqttCallback {&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void connectionLost(Throwable cause) {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 连接丢失后，一般在这里面进行重连&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(&amp;quot;连接断开，可以做重连&amp;quot;);&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void deliveryComplete(MqttDeliveryToken token) {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// publish后会执行到这里&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(&amp;quot;deliveryComplete---------&amp;quot;+ token.isComplete());&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void messageArrived(MqttTopic topic, MqttMessage message) throws Exception {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// subscribe后得到的消息会执行到这里面&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(&amp;quot;接收消息主题:&amp;quot;+topic.getName());&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(&amp;quot;接收消息Qos:&amp;quot;+message.getQos());&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(&amp;quot;接收消息内容:&amp;quot;+new String(message.getPayload()));&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2）服务端发布消息&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttClient;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttDeliveryToken;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttException;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttMessage;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttPersistenceException;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttTopic;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.internal.MemoryPersistence;&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;public class Server {&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public static final String HOST = &amp;quot;tcp://192.168.36.102:1883&amp;quot;;&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public static final String TOPIC = &amp;quot;tokudu/yzq124&amp;quot;;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private static final String clientid =&amp;quot;server&amp;quot;;&lt;/span&gt;   

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private MqttClient client;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private MqttTopic topic;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private String userName = &amp;quot;test&amp;quot;;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private String passWord = &amp;quot;test&amp;quot;;&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private MqttMessage message;&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public Server() throws MqttException {&lt;/span&gt;  
         &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//MemoryPersistence设置clientid的保存形式，默认为以内存保存&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client = new MqttClient(HOST, clientid, new MemoryPersistence());&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;connect();&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private void connect() {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;MqttConnectOptions options = new MqttConnectOptions();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setCleanSession(false);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setUserName(userName);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setPassword(passWord.toCharArray());&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置超时时间&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setConnectionTimeout(10);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置会话心跳时间&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setKeepAliveInterval(20);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;try {&lt;/span&gt;  
               &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.setCallback(new PushCallback());&lt;/span&gt;  
               &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.connect(options);&lt;/span&gt;  
               &lt;span class=&quot;l-Scalar-Plain&quot;&gt;topic = client.getTopic(TOPIC);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;} catch (Exception e) {&lt;/span&gt;  
               &lt;span class=&quot;l-Scalar-Plain&quot;&gt;e.printStackTrace();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void publish(MqttMessage message) throws MqttPersistenceException, MqttException{&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;MqttDeliveryToken token = topic.publish(message);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;token.waitForCompletion();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(token.isComplete()+&amp;quot;========&amp;quot;);&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public static void main(String[] args) throws MqttException {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;Server server =  new Server();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;server.message = new MqttMessage();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;server.message.setQos(1);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;server.message.setRetained(true);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;server.message.setPayload(&amp;quot;eeeeeaaaaaawwwwww---&amp;quot;.getBytes());&lt;/span&gt;  
         &lt;span class=&quot;l-Scalar-Plain&quot;&gt;server.publish(server.message);&lt;/span&gt;  
         &lt;span class=&quot;l-Scalar-Plain&quot;&gt;System.out.println(server.message.isRetained()+&amp;quot;------ratained状态&amp;quot;);&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;3.客户端接收消息&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import java.util.concurrent.Executors;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import java.util.concurrent.ScheduledExecutorService;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttClient;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttException;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttSecurityException;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.MqttTopic;&lt;/span&gt;  
&lt;span class=&quot;l-Scalar-Plain&quot;&gt;import org.eclipse.paho.client.mqttv3.internal.MemoryPersistence;&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;public class Client {&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public static final String HOST = &amp;quot;tcp://192.168.36.102:1883&amp;quot;;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public static final String TOPIC = &amp;quot;tokudu/yzq124&amp;quot;;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private static final String clientid = &amp;quot;client&amp;quot;;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private MqttClient client;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private MqttConnectOptions options;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private String userName = &amp;quot;test&amp;quot;;&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private String passWord = &amp;quot;test&amp;quot;;&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private ScheduledExecutorService scheduler;&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//重新链接&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void startReconnect() {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;scheduler = Executors.newSingleThreadScheduledExecutor();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;scheduler.scheduleAtFixedRate(new Runnable() {&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void run() {&lt;/span&gt;  
                &lt;span class=&quot;l-Scalar-Plain&quot;&gt;if (!client.isConnected()) {&lt;/span&gt;  
                    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;try {&lt;/span&gt;  
                        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.connect(options);&lt;/span&gt;  
                    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;} catch (MqttSecurityException e) {&lt;/span&gt;  
                        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;e.printStackTrace();&lt;/span&gt;  
                    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;} catch (MqttException e) {&lt;/span&gt;  
                        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;e.printStackTrace();&lt;/span&gt;  
                    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
                &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}, 0 * 1000, 10 * 1000, TimeUnit.MILLISECONDS);&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;private void start() {&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;try {&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// host为主机名，test为clientid即连接MQTT的客户端ID，一般以客户端唯一标识符表示，MemoryPersistence设置clientid的保存形式，默认为以内存保存&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client = new MqttClient(HOST, clientid, new MemoryPersistence());&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// MQTT的连接设置&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options = new MqttConnectOptions();&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置是否清空session,这里如果设置为false表示服务器会保留客户端的连接记录，这里设置为true表示每次连接到服务器都以新的身份连接&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setCleanSession(true);&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置连接的用户名&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setUserName(userName);&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置连接的密码&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setPassword(passWord.toCharArray());&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置超时时间 单位为秒&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setConnectionTimeout(10);&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置会话心跳时间 单位为秒 服务器会每隔1.5*20秒的时间向客户端发送个消息判断客户端是否在线，但这个方法并没有重连的机制&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setKeepAliveInterval(20);&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;// 设置回调&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.setCallback(new PushCallback());&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;MqttTopic topic = client.getTopic(TOPIC);&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//setWill方法，如果项目中需要知道客户端是否掉线可以调用该方法。设置最终端口的通知消息&lt;/span&gt;    
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;options.setWill(topic, &amp;quot;close&amp;quot;.getBytes(), 0, true);&lt;/span&gt;  

            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.connect(options);&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;//订阅消息&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;int[] Qos  = {1};&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;String[] topic1 = {TOPIC};&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.subscribe(topic1, Qos);&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;} catch (Exception e) {&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;e.printStackTrace();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public void disconnect() {&lt;/span&gt;  
         &lt;span class=&quot;l-Scalar-Plain&quot;&gt;try {&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.disconnect();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;} catch (MqttException e) {&lt;/span&gt;  
            &lt;span class=&quot;l-Scalar-Plain&quot;&gt;e.printStackTrace();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  



    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;public static void main(String[] args) throws MqttException {&lt;/span&gt;     
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;Client client = new Client();&lt;/span&gt;  
        &lt;span class=&quot;l-Scalar-Plain&quot;&gt;client.start();&lt;/span&gt;  
    &lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;l-Scalar-Plain&quot;&gt;}&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
				<pubDate>Wed, 10 Jun 2015 00:00:00 +0800</pubDate>
				<link>/java/2015/06/10/mqtt-java.html</link>
				<guid isPermaLink="true">/java/2015/06/10/mqtt-java.html</guid>
			</item>
		
			<item>
				<title>最短路径—Dijkstra算法</title>
				<description>&lt;h3 id=&quot;dijkstra&quot;&gt;Dijkstra算法&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;1.定义概览&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dijkstra(迪杰斯特拉)算法是典型的&lt;strong&gt;单源最短路径算法&lt;/strong&gt;，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。&lt;/p&gt;

&lt;p&gt;问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.算法描述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1)算法思想：&lt;/p&gt;

&lt;p&gt;设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。&lt;/p&gt;

&lt;p&gt;2)算法步骤：&lt;/p&gt;

&lt;p&gt;a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则&amp;lt;u,v&amp;gt;正常有权值，若u不是v的出边邻接点，则&amp;lt;u,v&amp;gt;权值为∞。&lt;/p&gt;

&lt;p&gt;b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。&lt;/p&gt;

&lt;p&gt;c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。&lt;/p&gt;

&lt;p&gt;d.重复步骤b和c直到所有顶点都包含在S中。&lt;/p&gt;

&lt;p&gt;执行动画过程如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/4851/d17917ada7d1acc9.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.算法实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先给出一个无向图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/4851/b166cc7b77a2d187.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用Dijkstra算法找出以A为起点的单源最短路径步骤如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/4851/625b8d3d2535b504.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 27 May 2015 00:00:00 +0800</pubDate>
				<link>/algorithm/2015/05/27/dijkstra.html</link>
				<guid isPermaLink="true">/algorithm/2015/05/27/dijkstra.html</guid>
			</item>
		
	</channel>
</rss>
